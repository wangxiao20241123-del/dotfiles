---
name: documentation-driven-development
description: Use when starting any non-trivial feature or project, before writing any implementation code
---

# 文档驱动开发

## 概述

先写文档，再写测试，最后写代码。每个阶段产出一份文档，驱动下一个阶段。不跳过任何阶段。每份文档必须经过 review 才能进入下一阶段。

**核心原则：** 如果你不能用文档描述清楚，你就不可能正确实现它。

**启动声明：** "我正在使用「文档驱动开发」skill，按照 文档 → 测试 → 代码 的完整流程推进这个功能。"

## 流程总览

```
阶段 1: 理解需求     → （对话，无产出物）
阶段 2: 设计文档     → .sisyphus/plans/{feature}/design-doc.md
阶段 3: API 契约     → 代码产出物（proto / types.go / OpenAPI）
阶段 4: 行为规格     → .sisyphus/plans/{feature}/behavior-spec.md
阶段 5: 测试计划     → .sisyphus/plans/{feature}/test-plan.md
阶段 6: 实现         → 测试代码 → 实现代码（TDD）
```

**门禁规则：** 每个阶段结束时说"已完成，等待 review。"在用户确认之前，**不得**进入下一阶段。

## 阶段 1：理解需求

**目标：** 确保你和用户对"做什么"和"为什么做"达成一致。

1. 阅读项目已有的架构文档（如果存在）
2. 每次只问**一个问题**来澄清：
   - 这个功能解决什么问题？
   - 谁是使用者/调用方？
   - 有什么约束条件？
   - 什么是明确不做的（非目标）？
3. 用 3-5 个要点总结你的理解
4. 说：**"以上是我的理解，是否正确？"**

**出口门禁：** 用户确认理解正确。

## 阶段 2：设计文档

**目标：** 产出一份设计文档，说清楚做什么、为什么做、怎么做。

1. 阅读设计文档模板：`documentation-driven-development/design-doc-template.md`
2. 调研代码库，理解现有的模式、模块和约定
3. 按照模板编写设计文档
4. 保存到 `.sisyphus/plans/{feature-name}/design-doc.md`
5. 向用户展示**摘要**（不是全文）
6. 说：**"设计文档已保存，等待 review。"**

**出口门禁：** 用户 review 并批准。如果有反馈，修改后重新展示。

## 阶段 3：API 契约

**目标：** 定义精确的接口——这是可执行的文档。

契约的形式取决于项目类型：

| 项目类型 | 契约形式 |
|----------|---------|
| gRPC | `.proto` 文件 |
| REST | OpenAPI spec |
| K8s Operator | `*_types.go` + kubebuilder markers |
| 库 / SDK | 公开接口的类型签名 |
| CLI | 命令、参数、输出格式定义 |

1. 基于设计文档，定义所有公开接口
2. 将契约写成**实际的代码文件**（不是 markdown）
3. 在代码中用注释/注解说明设计意图
4. 说：**"API 契约已定义，等待 review。"**

**出口门禁：** 用户 review 契约代码。这些是真实代码——一旦批准，就是唯一的事实来源。

**关键原则：** 契约就是代码。`.proto` 生成 stub，`*_types.go` 生成 CRD。这是字面意义上的"文档即代码"。

## 阶段 4：行为规格

**目标：** 用 Given-When-Then 格式描述每个接口的每个行为。每条行为 = 一个未来的测试用例。

1. 阅读行为规格模板：`documentation-driven-development/behavior-spec-template.md`
2. 对阶段 3 定义的每个 API/接口，枚举：
   - 正常路径行为
   - 错误/边界条件行为
   - 幂等性行为（如适用）
   - 并发行为（如适用）
3. 用结构化的 Given-When-Then 格式编写
4. 保存到 `.sisyphus/plans/{feature-name}/behavior-spec.md`
5. 说：**"行为规格已保存，等待 review。"**

**出口门禁：** 用户 review。这里列出的每条行为都会变成一个测试。漏掉一条行为 = 漏掉一个测试。

## 阶段 5：测试计划

**目标：** 将阶段 4 的每条行为映射到具体的测试，按测试层级组织。

1. 阅读测试计划模板：`documentation-driven-development/test-plan-template.md`
2. 对行为规格中的每条行为，决定：
   - 在哪个测试层级验证（单元 / 集成 / E2E）？
   - 用什么测试框架/工具？
   - 什么需要 mock，什么用真实依赖？
   - 精确的断言是什么？
3. 组织成测试矩阵
4. 保存到 `.sisyphus/plans/{feature-name}/test-plan.md`
5. 说：**"测试计划已保存，等待 review。"**

**出口门禁：** 用户 review。review 通过后，开始实现。

## 阶段 6：实现

**目标：** 先写测试，再写代码让测试通过。纯 TDD。

1. 按测试计划的顺序，对每个测试：
   a. 写测试（应该**失败** — RED）
   b. 运行测试，确认失败原因正确
   c. 写最少的代码让测试通过（GREEN）
   d. 运行测试，确认通过
   e. 必要时重构（REFACTOR）
   f. 提交
2. 所有测试通过后，运行完整测试套件
3. 如果设计引入了重大变更，更新架构文档
4. 说：**"实现完成，所有测试通过。"**

## 何时停下来问

**立即停止，当：**
- 行为规格中有歧义——无法写出清晰的测试
- 实现过程中需要修改 API 契约
- 测试暴露了设计缺陷
- 发现与现有代码的冲突

**回退到对应的阶段。** 不要向前打补丁。

## 何时简化阶段

**永远不要跳过阶段 2（设计文档）**——这是基础。

阶段 3-5 可以根据变更规模简化：
- 简单 bug 修复：阶段 2（简要）→ 阶段 6（仅 TDD）
- 内部重构：阶段 2（简要）→ 阶段 4（行为规格证明无回归）→ 阶段 6
- 新 API / 新功能：所有阶段，完整深度

## 文档生命周期

实现完成并合并后：
- 设计文档：将关键决策沉淀到架构文档或 ADR 中，删除计划文档
- 行为规格：作为测试文档继续存在（测试本身就是规格）
- 测试计划：删除——实际的测试代码取代了它

## 铁律

- 文档驱动测试，测试驱动代码——永远不要反过来
- 每个阶段门禁需要用户明确批准
- API 契约是代码，不是 markdown
- 行为规格中的每条行为 = 恰好一个测试用例
- 需要时回退，不要向前打补丁
- 实现完成后删除计划文档——测试是活的文档
